/** @param {NS} ns **/

/*----------
All require root access on target;

hack: time depends on hacking and security. requires enough skill. security +0.002 (base)
grow: time depends on hacking and security. No skill req. security +0.004 (base)
weaken: time depends on hacking and security. security -0.05 (base, effected by cores)

== TOOLS ==
W -Sec 1 ns.weakenAnalyze(threads, **cores?) - returns amt weakened by this number of threads
G +Sec 1 ns.growthAnalyzeSecurity(threads)
G ?Thr 1 ns.growthAnalyze(host, growthMultiplier, **cores?) - returns number of threads needed == don't care for 1 core, low threads
H +Sec 1 ns.hackAnalyzeSecurity(threads)
H -$%  1 ns.hackAnalyze(host)
H Chnc 1 ns.hackAnalyzeChance(host) - Chance of success (only matters for valuation)
W Time 0.05 ns.getWeakenTime(host) - Time in ms to complete
G Time 0.05 ns.getGrowTime(host) - Time in ms to complete
H Time 0.05 ns.getHackTime(host) - Time in ms to complete

CORES only affect: Weaken Magnitude (makes weaken more Powerful) and Grow Magnitude (makes Grow more powerful)
They can be safely ignored, at least in the beginning... (they technically just reduce the number of grow/weaken threads needed per hack thread)

core multiplier = 1 + (cores - 1) / 16

----------*/
import * as nt from "notns.js";

const bestThresh = 1.10; //How much swapping targets has to be worth to bother

const MaxAmt = 0.95; // max amount to steal per hack (decimal%) //lower helps maintain stability
export const MaxProcess = 8000; //Maximum allowed concurrent processes
const BN = 1.10; //buffer threads extra grow and weaken threads to help keep stability
//const ProcPerbT = 10000; //how many processes before increasing bT
const MinbT = 10;//MINIMUM buffer time betwwen calls in milliseconds (time between each hack, grow, weaken, landing) to ensure sequence is kept
// lower buffer = more hack grow pairs = more money (more effecient to a point)
// but also means more chance of collissions and greater rounding error accumulation, which = reduced money
const RamUse = 0.90 // Amount of your total ram to allow profiles to build from

//  tar is the target server's name (ex 'n00dles') as a string
//  hN is the desired number of Hack threads to simulate for
//  tarDat is a server object (ns.getServer()) for the target server, and is optional.
//    If not provided, the idealized values will be used instead (from MasterData)
//  bT is a parameter in case you have other tasks that may require you to temporarily hack at a slower rate
//    The global constant MinbT should be set instead for normal operation
//  cores should be used to increase totRam and calculate actual launched threads at time of launch instead
//    but is provided for here for sutuations where all or most processes get run on home - for instance
function estBestScore(tar, hN, tardat = {}, bT = MinbT, cores = 1) { //tar = target server: string, hN = number of hack threads to model: integer > 0
	const ret = { tar: tar, value: 0, score: 0, hN: hN };
	if (tardat == {}) try { tardat = asd.servers.dat[asd.servers.dat.indexof(tar) + 1]; } catch { return ret; }
	if (tardat == {}) { return ret; } //can't get dat, abort

	//determine hack amt, chamce, and thread count numbers for hack, etc. (hN, gN, wN)
	ret.hA = tardat.hA; //hack Amount PER THREAD
	ret.amt = ret.hA * ret.hN; //amt hacked (as portion of currentMoney) -- if Hacking/Growing properly, then of MaxMoney
	ret.hS = nt.hAnalyzeSecurity(ret.hN); //amount of security generated by each hack
	const postHackSec = Math.min(100, tardat.minDifficulty + ret.hS); //security level after hack hits (max 100)
	ret.gN = Math.max(1, Math.ceil(BN * nt.gAnalyzeLost(tardat, asd.player, ret.amt, postHackSec))); //number of Grow threads needed to offset each hack
	ret.gS = nt.gAnalyzeSecurity(ret.gN); //amount of security generated by the Grow threads
	const postGrowSec = Math.min(100, tardat.minDifficulty + ret.gS); //security level after hack hits
	ret.hC = 0.5 * (nt.hAnalyzeChance(tardat, asd.player) + nt.hAnalyzeChance(tardat, asd.player, postGrowSec));  // chance for a successful hack (at avg of minSec and minSec+growSec) - basically, assume hack lands first about half the time
	ret.maxSI = 100 - tardat.minDifficulty; // Caps weaken threads (max security is 100, so max security needing weaken is 100-minSec)
	ret.wA = nt.wAnalyze(1, cores); //amount of security offset by each weaken thread
	ret.wN = Math.max(1, Math.ceil(Math.min(ret.maxSI, (2 * BN * (ret.hS + ret.gS))) / ret.wA)); // number of weaken threads needed to offset each HackGrow pair

	//determine process counts
	ret.hT = tardat.hT; // time required to finish a minSec Hack
	ret.gT = tardat.gT; // time required to finish a minSec Grow
	ret.wT = tardat.wT; // time required to finish a minSec Weaken
	ret.bT = Math.ceil(Math.max(bT, (ret.hT * 8.2 / 3.0 / MaxProcess))); // Buffer Time between attacks
	ret.cL = 3.0 * ret.bT; // length of a cycle (hgw)
	ret.hP = Math.ceil(ret.hT / ret.cL); //number of Hack processes continuously running
	ret.gP = Math.ceil(1.0 * ret.gT / ret.cL); //number of Grow processes continuously running
	ret.wP = Math.ceil(1.0 * ret.wT / ret.cL); //number of Weaken processes continuously running
	ret.totP = ret.hP + ret.gP + ret.wP; //total number of processes to run this profile

	//put it all together
	ret.cost = nt.sFiles[4] * ret.hN * ret.hP + nt.sFiles[6] * ret.gN * ret.gP + nt.sFiles[2] * ret.wN * ret.wP; //cost in GB
	ret.value = ret.amt * tardat.moneyMax * ret.hC / ret.cL; // $ per millisecond
	ret.score = ret.value / ret.cost; // $ / ms / GB
	return ret;
}

async function fixem(ns) {
	//fill small servers with fixem scripts
	var script = nt.sFiles[7]; //fixem
	var smls = []; try { smls = asd.servers.sml; } catch { return; }
	for (const sml of smls) {
		await ns.sleep(1);
		if (nt.canRun(sml, script)) {
			const th = nt.maxThreads(sml, script); //threads to assign to this attack
			//var uid = Math.random();
			ns.exec(script, sml, th);
		}
	}
}

let asd = {}; //all script data
export async function main(ns) {
	if (!Math.asd) { Math.asd = asd; } //if port's empty, initialize it
	asd = Math.asd; //if port's not empty, populate asd
//	if (asd && !Array.isArray(asd.hmTargets)) { asd.hmTargets = []; }
	if (asd && !Array.isArray(asd.bests)) { asd.bests = []; }

	ns.disableLog('disableLog');
	ns.disableLog('sleep');
	ns.disableLog('clearLog');
	ns.disableLog('getServerMaxRam');
	ns.disableLog('getServerUsedRam');
	ns.disableLog('getServerMaxMoney');
	ns.disableLog('exec');
	ns.disableLog('getServerMinSecurityLevel');
	ns.clearLog();

	let loop = false;
	if (ns.args.includes('loop')) { loop = true; }

	let count = 0;
	do {
		//copy scripts
		ns.exec('sendem.js', 'home');
		await fixem(ns);

		await ns.sleep(50);
		//update data
		let tars = []; try { tars = asd.servers.tar; } catch { continue; }
		let dats = []; try { dats = asd.servers.dat; } catch { continue; }
		let bests = []; try { bests = asd.bests; } catch { continue; }

		for (const tar of tars) {
			await ns.sleep(1);
			let tardat = {};
			const di = dats.indexOf(tar) + 1;
			if (di > 0) { tardat = dats[di]; }
			else { continue; }

			let hN = 1;
			const maxCost = RamUse * asd.totRam;
			let ret = { tar: tar, value: 0, score: 0, cost:0, hN: hN, bT: MinbT };

			//todo figure out how to do indexOf for a property in an array of objects the right way
			let bi = -1; for (let j = 0; (bi == -1) && (j < bests.length); j++) { if (bests[j].tar == tar) { bi = j; } } //ToDo: figure out how to do index of by object property
			if (bi == -1) { bi = bests.length; bests.push(ret); } // add the new target to the profiles list
			else if (!((maxCost - bests[bi].cost > 0) && (MaxAmt - bests[bi].amt > 0))) { bests[bi] = ret;} //check that profile is still valid
			do {
				await ns.sleep(0);

				//check for a better target
				ret = estBestScore(tar, hN, tardat);
				while (hN == 1 && (ret.cost / maxCost > 1.0)) { //hN 1 profile to expensive, lengrhen cL to reduce cost
					await ns.sleep(0);
					ret = estBestScore(tar, hN, tardat, Math.ceil(ret.bT * ret.cost / maxCost));
				}
				if (ret.score > 0 && maxCost - ret.cost > 0 && (hN == 1 || MaxAmt - ret.amt > 0) && ret.value - bests[bi].value > 0) { //new best target
					bests[bi] = ret;
				}
				if (count%10 == 9) { hN++; } else { //high detail pass every 10th
					if (ret.amt < 0.01) { hN += hN < 10 ? 1 : hN < 100 ? 10 : Math.ceil(0.0001 / tardat.hA); } //step by 0.01%
					else { hN += Math.ceil(0.02 / tardat.hA); } //step by 0.2%
				}
			} while ((ret.score > 0) && (maxCost - ret.cost > 0) && (MaxAmt - ret.amt > 0))
			//updated best profile for server, re-sort and update global to new order (and profile)
		}
		bests.sort((a, b) => (b.value - a.value > 0) ? 1 : (b.value == a.value) ? ((b.cost - a.cost > 0) ? -1 : 1) : -1);
		asd.bests = bests;
		count++;
	} while (loop);
	ns.print('== MasterStrat complete ==');
}
